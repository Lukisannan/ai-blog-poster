# Blog Post Creator API App Flow Document

## Onboarding and Sign-In/Sign-Up
A developer who wants to use the Blog Post Creator API begins by cloning the repository or installing the package via pip. After that, they create a `.env` file in the project root, placing their OpenAI API key and any optional configuration values such as a default domain prefix. They ensure Python 3.11 or higher is installed and install the required dependencies using a standard command like `pip install -r requirements.txt`. To start the API server, they run a Uvicorn command that points to the FastAPI application. Because this proof of concept does not require authentication, no further sign-up or login steps are necessary. The developer can immediately send requests to the server once it is running.

## Main Dashboard or Home Page
When the API server is running, the developer can point their browser to `http://localhost:8000/docs` to find the interactive Swagger UI. This documentation page shows all available endpoints, expected request parameters, and response schemas. The root path `/` returns a basic JSON object confirming the API is alive, while the OpenAPI schema is available at `/openapi.json`. From the Swagger UI, the developer can quickly execute test calls against each endpoint, view example payloads, and inspect returned data structures without writing any client code.

## Detailed Feature Flows and Page Transitions
The primary workflow begins with the developer discovering what options the API supports by calling the metadata endpoint. They issue a `GET` request to `/metadata/config` and receive a JSON object listing supported languages, file formats, and component tags. With that information in hand, the developer composes a JSON configuration object for content generation.

Next, the developer prepares to generate images by sending a `POST` request to `/generate/image`. In the request body, they include a slugified content cluster name, a natural language prompt, and the number of images desired. The API invokes the OpenAI gpt-image-1 model, generates each image, and saves them in a folder named after the content cluster. Filenames are slugified and returned in a JSON list so the developer can embed them in their blog post.

Once the images are available, the developer submits a `POST` request to `/generate/blog` with parameters such as target keywords, preferred language, word count, formatting choice (`.md`, `.mdx`, or `.txt`), and the local image paths. They also include custom frontmatter rules and internal linking configuration that determines whether links use relative paths or a provided domain prefix. The gpt-4o-mini model processes these instructions, applies SEO rules, injects keywords into titles and headings, and assembles the blog post. When generation is complete, the API writes one or more content files into the same content cluster folder and returns their file paths in the response.

Within a single client integration, these endpoints are called sequentially. A script or Zapier workflow can programmatically fetch metadata, generate images, and then invoke blog creation. Because the API is stateless, each request is independent, but the developer’s own code orchestrates the order and handles the local file outputs for further processing.

## Settings and Account Management
All configurable settings live in environment variables and in the per-request JSON payloads. The developer may update the `.env` file at any time to change the OpenAI API key or adjust a default domain prefix for internal links. If they wish to alter supported formatting rules or frontmatter fields permanently, they modify the API’s configuration file or source code and restart the server. After saving changes, a quick restart of the Uvicorn process will load the new settings. No user accounts exist, so account management consists solely of managing the `.env` file and any application-level configuration files.

## Error States and Alternate Paths
If a request contains invalid or missing fields, the API responds with a 422 status code and a JSON payload describing each validation error. When the OpenAI service returns an error or times out, the API logs an ERROR message with details and returns a 500 response containing an error message. File system issues, such as insufficient permissions or missing directories, also result in 500 errors and are logged with stack traces. In all error cases, the developer can review console logs or redirect output to a log file for structured debugging. Once corrective action is taken—such as fixing the request body, restoring connectivity, or adjusting file permissions—the developer simply retries the request to resume normal operation.

## Conclusion and Overall App Journey
In this proof of concept, a developer quickly integrates the Blog Post Creator API by installing dependencies, configuring environment variables, and starting the FastAPI server. They explore available options in the interactive documentation, fetch configuration metadata, generate a hero image and supporting visuals, and then create one or more SEO-optimized blog posts with custom frontmatter, formatting choices, and internal links. All outputs are saved in a well-organized folder structure based on content clusters, enabling downstream pipelines or CMS imports. Throughout the process, informative logs provide visibility into successes and failures, and the straightforward design allows future extensions such as authentication, asynchronous processing, and rate limiting without altering the core user experience.